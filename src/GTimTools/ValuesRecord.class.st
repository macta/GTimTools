"
I am collection of key/value pairs that record a useful interaction that can be explored in a GtView via a `ValuesRecorder`.
"
Class {
	#name : #ValuesRecord,
	#superclass : #Object,
	#instVars : [
		'recorder',
		'values'
	],
	#classInstVars : [
		'values'
	],
	#category : #GTimTools
}

{ #category : #accessing }
ValuesRecord class >> for: associationsArray [

	^self new
		values: associationsArray asDictionary;
		yourself
]

{ #category : #accessing }
ValuesRecord >> at: symbolName put: anObject [
	self values at: symbolName put: anObject
]

{ #category : #accessing }
ValuesRecord >> defaultViewFor: anObject [
	^(anObject gtViewsInContext: GtPhlowContext new) first
]

{ #category : #accessing }
ValuesRecord >> defaultViewFromPragmaFor: anObject [
	| pragmas views |
	
	pragmas := ((anObject class withAllSuperclasses) flatCollect: [ :c | c pragmas ])
			select: [ :p | p key = #gtView ].

	views := pragmas
			collect: [ :p | 
				anObject
					perform: p method selector
					withEnoughArguments: {GtPhlowEmptyView new.
							Dictionary new} ].

	^ (views detectMin: [ :v| v priority ]) 
]

{ #category : #accessing }
ValuesRecord >> gtDetailsFor: aView [
	<gtView>
	
	self values ifEmpty: [^aView empty ].
	
	^aView columnedList
		title: 'Values';
		priority: 10;
		items: [ self values associations ];
		column: 'attribute' text: [:v | v key ] width: 100;
		column: 'value' text: #value;
		send: #value;
		yourself.
		
		
	
]

{ #category : #accessing }
ValuesRecord >> gtViewsInContext: aContext [
	"Override the default view mechanism to insert some autogenerated top level views"
	
	| generatedViews defaultViews |
	
	generatedViews := self values associations
			collect: [ :v | 
				(self defaultViewFor: v value)
					title: v key capitalized;
					yourself ].

	defaultViews := super gtViewsInContext: aContext.
	
	^ (OrderedCollection with: defaultViews first)
		addAll: generatedViews;
		addAll: defaultViews allButFirst;
		yourself
]

{ #category : #accessing }
ValuesRecord >> names [
	^self values keys
]

{ #category : #accessing }
ValuesRecord >> valueFor: aSymbol [
	^self values at: aSymbol ifAbsent: [ nil ]
]

{ #category : #accessing }
ValuesRecord >> values [
	^values ifNil: [values := Dictionary new]
]

{ #category : #accessing }
ValuesRecord >> values: aDictionary [
	values := aDictionary
]
